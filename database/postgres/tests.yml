CreateTable:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE bigdata (
      id bigint,
      created_at timestamp with time zone,
      created_date time with time zone,
      fn integer default foo.my_func()
    );
CreateTableWithConstrant:
  sql: |
    CREATE TABLE tbl (
      id bigint,
      user_id bigint,
      email text,
      PRIMARY KEY (id),
      CONSTRAINT uniq_email UNIQUE (email),
      CONSTRAINT user_id_fk FOREIGN KEY (user_id) REFERENCES users(id, name)
    );
CreateTableWithConstrantInlineColumn:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE tbl (
      id bigint PRIMARY KEY,
      user_id bigint REFERENCES users(id, name),
      email text UNIQUE
    );
CreateTableWithDefault:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE users (
      default_null integer default null,
      default_int integer default 20,
      default_bool bool default true,
      default_numeric numeric(5, 0) default 42.195,
      default_fixed_char character(3) default 'JPN'::bpchar,
      default_json json default '[]',
      default_json_with_cast json default '[]'::json,
      default_jsonb jsonb default '[]'::jsonb,
      default_current_timestamp timestamp default CURRENT_TIMESTAMP,
      default_current_date date default CURRENT_DATE,
      default_current_time time default CURRENT_TIME,
      default_array_int integer[] default '{}'::integer[],
      joined_at timestamp with time zone NOT NULL DEFAULT '0001-01-01 00:00:00'::timestamp without time zone
    );
CreateTableWithDefaultWithoutCompare:
  # Queries that cannot be parsed with generic parse OR results do not match
  sql: |
    CREATE TABLE users (
      default_int int default true,
      default_bool boolean default true,
      default_text text default '',
      default_now timestamp default now(),
      default_text_with_cast text default ''::text,
      default_array_constructor int[] DEFAULT ARRAY[],
      default_array_constructor_with_cast int[] DEFAULT ARRAY[]::int[]
    );
CreateTableWithSchema:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE public.bigdata (
      data bigint
    );
CreateTableWithNotNull:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE public.airline_confirmation (
      airline_id bigint,
      code varchar(512),
      booking_id bigint NOT NULL
    );
CheckConstraint:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE test (
      v varchar(10) CHECK (v::text ~ '[0-9]'::text)
      -- price integer CHECK (price = 0 OR NOT price <= '-1'::integer AND price IS NULL)
      -- min_value integer CONSTRAINT test_min_value_check CHECK (min_value > 0),
      -- max_value integer CHECK (max_value > 0) NO INHERIT,
      -- quantity integer,
      -- CONSTRAINT chk CHECK (quantity > 0 AND price > 0)
    );
CheckConstraintBetween:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE test (
      d1 date CHECK (d1 BETWEEN '1900-01-01' AND '2000-01-01'),
      d2 date CHECK (d2 NOT BETWEEN '1900-01-01'::date AND '2000-01-01'::date)
    );
CheckConstraintPosixRegex:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE test (
      posix_regex        text NOT NULL CHECK (posix_regex        ~   '[0-9]'),
      posix_regex_ci     text NOT NULL CHECK (posix_regex_ci     ~*  '[0-9]'),
      posix_not_regex    text NOT NULL CHECK (posix_not_regex    !~  '[0-9]'),
      posix_not_regex_ci text NOT NULL CHECK (posix_not_regex_ci !~* '[0-9]')
    );
CheckConstraintWithoutCompare:
  sql: |
    CREATE TABLE test (
      t1 text CHECK (t1 like 'x'),
      t2 text CHECK (t2 not like 'x'),
      t3 text CHECK (t3 similar to 'x'),
      t4 text CHECK (t4 <> ''::text),
      d3 date CHECK (d3 BETWEEN SYMMETRIC '1900-01-01' AND '2000-01-01'),
      d4 date CHECK (d4 NOT BETWEEN SYMMETRIC '1900-01-01'::date AND '2000-01-01'::date)
    );
CreateView:
  compare_with_generic_parser: true
  sql: |
    create view hoge_view as
    select amount from hoge;
CreateViewWithCast:
  compare_with_generic_parser: true
  sql: |
    create view hoge_view as
    select amount::numeric(10,2) from hoge;
CreateViewWithFullColumn:
  # compare_with_generic_parser: true
  sql: |
    CREATE VIEW public.hoge_view
    AS SELECT (hoge.amount)::numeric(10,2) AS amount_num FROM hoge;
# CreateViewWithCaseWhen2:
#   compare_with_generic_parser: true
#   sql: |
#     CREATE VIEW public.hoge_view AS SELECT (hoge.amount)::numeric(10,2) AS amount_num1, (jsonb_extract_path_text(hoge.payload, VARIADIC ARRAY['amount'::text]))::numeric(10,2) AS amount_num2, ( CASE hoge.hoge_type WHEN 'hoge'::text THEN jsonb_extract_path_text(hoge.payload, VARIADIC ARRAY['hoge'::text, 'amount'::text]) ELSE NULL::text END)::numeric(10,2) AS amount_num3, to_timestamp(((jsonb_extract_path_text(hoge.payload, VARIADIC ARRAY['created'::text]))::bigint)::double precision) AS created, (to_timestamp(((jsonb_extract_path_text(hoge.payload, VARIADIC ARRAY['created'::text]))::bigint)::double precision))::date AS created_date FROM hoge;
CreateViewWithCaseWhen:
  # compare_with_generic_parser: true
  sql: |
    create view hoge_view as
    select
      -- pattern 1
      amount::numeric(10,2) as amount_num1,
      -- pattern 2
      (
        jsonb_extract_path_text(payload, 'amount')
      )::numeric(10,2) as amount_num2,
      -- pattern 3
      (
        case hoge_type
          when 'hoge' then jsonb_extract_path_text(payload, 'hoge', 'amount')
        end
      )::numeric(10,2) as amount_num3,
      -- pattern 4
      (
        to_timestamp(
          jsonb_extract_path_text(payload, 'created')::bigint
        )
      ) as created,
      -- pattern 5
      (
        cast(
          to_timestamp(
            jsonb_extract_path_text(payload, 'created')::bigint
          ) as date
        )
      ) as created_date
    from hoge;
CreateViewWithoutFrom:
  sql: |
    create view v as select 10 as n;
CreateViewWithStarExpr:
  compare_with_generic_parser: true
  sql: |
    create view hoge_view as
    select t.* from hoge t;
CreateIndex:
  compare_with_generic_parser: true
  sql: |
    CREATE INDEX username on users using btree (name asc);
CreateIndexWithFuncCall:
  sql: |
    CREATE UNIQUE INDEX airline_confirmation_code_unique_idx
    ON public.airline_confirmation
    USING btree (airline_id, booking_id, lower((code)::text))
    WHERE ((code IS NOT NULL) AND (airline_id IS NOT NULL));
CreateIndexConcurrently:
  sql: |
    CREATE INDEX CONCURRENTLY username on users (name);
AlterTableUnique:
  compare_with_generic_parser: true
  sql: |
    ALTER TABLE users ADD CONSTRAINT username UNIQUE (name, age);
AlterTableAddForeignKey:
  compare_with_generic_parser: true
  sql: |
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE RESTRICT;
